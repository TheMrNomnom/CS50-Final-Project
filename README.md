# Inventory Management
#### Video Demo:  XXXXXX
#### Description:

My project is an inventory management system. It is designed to be intuitive and easy to use. It was designed to allow significantly easier introduction and migration to new features and tools. This was a design decision that shows in the fact that I have created two versions of the app. This program is designed to be a web app running in (Python) Flask and supports authentication. The webpages are made in HTML and CSS, and include JavaScript inside those files. The database management is written in SQL and uses the SQLAlchemy module.

"main.py" is the file that starts the app creation in Flask. Moving deeper into the filesystem into the "website" directory, there are numerous Python files and two directories named "static" and "templates". The "__init__.py" file creates the Flask app with the proper configuration necessary for the app. SQLAlchemy, the Flask session, LoginManager, and the Flask "Blueprints" are all set up in this file. In relation to this file: "inventory.db" is the database that is managed by the SQLAlchemy module and is meant to be initialized in this file as well. "models.py" defines the database models that set up the SQL tables in the inventory.db file. There are three models/tables defined: users, locations, and items. There is a one-to-many relationship between the items and locations tables. The users model is created with a UserMixin to allow it to be used with the Flask Login Manager. "auth.py" is a file that defines three routes: login, logout and register. The "register" route, like all other routes performs error checking, and uses my password validation method from my Finance submission. The login, logout, and tracking the session are managed by Flask Login Manager. "endpoints.py" contains routes to endpoints that provide JSON responses to specific queries made by GET requests about item info or location info. "helpers.py" contains a function that converts a SQLAlchemy query to a dict to make iteration possible in Jinja. "views.py" contains five routes: "/" (home), "/add", "/edit", "/delete", and "/variance-calculator". "/" displays all the items in the inventory, "/add" allows addition of items and locations, "/edit" allows editing of items and locations, "/delete" allows deletion of items and locations (and a feature to reassign items assigned to a location if it is going to be deleted), "/variance-calculator" is a calculator to get the price variance per unit of an item. The directory of "static" contains the CSS. The directory "templates" contains all the HTML files for the site. The HTML files correspond to the routes they are named after. There is a variety of tags, XHR, JS, and Jinja templating to display and manipulate the data in the inventory.

I created two separate versions (unintentionally) of this web app. The first is a fully functional application that does most of the same functions as the second version, however it uses the CS50 library to perform raw SQL queries. The second version uses an ORM (object-relational mapping) implementation of a SQL based database, as I realized that an ORM would be significantly more modular and allow for easier database management. A design choice that I had to make while I was creating the delete function for location was reassignment. I asked myself, "what would a reasonable approach be to handle the items that assigned to the location that is to be deleted?" I realized that the user would like a choice between fully deleting a location and it's assigned items, or be allowed to reassign all the items assigned to the location to another location before deleting. I also had to use the SQLAlchemy_SerializerMixin in order to make the endpoints.py JSON responses possible (SQLAlchemy objects are able to be serialized to JSON natively). The second version also redirects using the "url_for" function instead of redirecting straight to a URL so now I can safely change URLs if necessary and the redirects will not break.
